<template>
    <ion-grid> 
        <ion-row
            v-for="(fields, rowIndex) in fieldRows"
            :key="rowIndex"
            > 
            <ion-col
                v-for="(field, fieldIndex) in fields" 
                :key="fieldIndex"
                :size-sm="field?.colSizes?.sm || ''"
                :size-md="field?.colSizes?.md || ''"
                :size-lg="field?.colSizes?.lg || ''" >
                <ion-row> 
                    <ion-col> 
                        <ion-label position="stacked">
                        {{ updateFieldHelpText(field) }}
                        <span v-if="updateFieldRequired(field)">(*)</span>
                        </ion-label>
                    </ion-col>
                </ion-row>
                <ion-row> 
                    <ion-col>    
                    <keep-alive> 
                    <component
                        v-bind:is="field.type"
                        v-if="updateFieldVisibility(field)"
                        :beforeValue="field.beforeValue"
                        :required="updateFieldRequired(field)"
                        :options="updateFieldOptions(field)"
                        :defaultValue="updateFieldDefaultValue(field)"
                        :disabled="updateFieldDisabled(field)"
                        :config="field.config ? field.config: {}"
                        @onValue="(val) => onValue(val, field)">
                    </component>
                    </keep-alive>
                    </ion-col>
                </ion-row>
                <ion-row> 
                    <ion-col> 
                    <!---Render field Errors here--->
                    </ion-col>
                </ion-row>
            </ion-col>
        </ion-row>
    </ion-grid>
</template>

<script lang="ts">
import { defineComponent, PropType } from 'vue'
import { DerivedInterface, DtFieldInterface } from "@/components/Forms/DesktopForms/DTFieldInterface"
import { Option } from "@/components/Forms/FieldInterface"
import { DesktopFormElements } from "@/components/Forms/DesktopForms/DTFormElements"
import {
    IonGrid,
    IonRow,
    IonCol,
    IonLabel,
    IonItem,
} from "@ionic/vue"
import { isEmpty } from 'lodash'
export default defineComponent({
    components: { 
        IonGrid, 
        IonRow, 
        IonCol,
        IonItem,
        IonLabel,
        ...DesktopFormElements
    },
    props: {
        fields: {
            type: Object as PropType<DtFieldInterface[]>,
            required: true   
        }
    },
    data: () => ({
        fieldRows: [] as Array<DtFieldInterface[]>,
        formData: {} as Record<string, Option | Option[] | null>,
        computedData: {} as Record<string, any>,
        /**Track the field which is emitting a value */
        curFieldUpdate: { } as { 
            field: string;
            value: Option | Option[] | null;
        },
        /**Stores values generated by observer methods which derive data */
        observerValueCache: {} as Record<string, any>
    }),
    watch: {
        fields: {
            handler(fields: DtFieldInterface[]) {
                if (!isEmpty(fields)) {
                    this.setFormData(fields)
                    this.fieldRows = this.buildFieldRows(fields)
                }
            },
            deep: true,
            immediate: true
        }
    },
    methods: {
        onValue(value: Option | Option[] | null, field: DtFieldInterface) {
            this.curFieldUpdate.field = field.id
            this.curFieldUpdate.value = value
            this.formData[field.id] = value
            if (value) {
                if (field.computeValue && value) {
                    this.computedData[field.id] = field.computeValue(
                        value, this.formData, this.computedData
                    )
                }
            }
        },
        setFormData(fields: Array<DtFieldInterface>): void {
            this.formData = {};
            fields.forEach((field) => this.formData[field.id] = null)
        },
        updateField(
            fieldID: string,
            watcher: DerivedInterface | undefined, 
            configuredValue: 
                undefined 
                | string
                | number
                | boolean
                | Option[],
            defaultValue: any,
            ) {
            if (watcher!=undefined && !isEmpty(this.curFieldUpdate)) {
                if (isEmpty(watcher.observes) 
                    || watcher.observes.includes(this.curFieldUpdate.field)) {
                    this.observerValueCache[fieldID] = watcher.update(
                        this.curFieldUpdate, 
                        this.formData, 
                        this.computedData
                    )
                    return this.observerValueCache[fieldID]
                }
                if (this.observerValueCache[fieldID]) {
                    return this.observerValueCache[fieldID]
                }
            }
            if (configuredValue != undefined) {
                return configuredValue
            }
            return defaultValue
        },
        updateFieldHelpText(field: DtFieldInterface) {
            return this.updateField(field.id, field.onUpdateHelpText, field.helpText, 'Unknown')
        },
        updateFieldOptions(field: DtFieldInterface) {
            return this.updateField(field.id, field.onUpdateOptions, field.options, [])             
        },
        updateFieldVisibility(field: DtFieldInterface) {
            return this.updateField(field.id, field.onUpdateVisible, field.visible, true)
        },
        updateFieldDefaultValue(field: DtFieldInterface) {
            return this.updateField(field.id, field.onUpdateDefaultValue, field.defaultValue, null)
        },
        updateFieldDisabled(field: DtFieldInterface) {
            return this.updateField(field.id, field.onUpdateDisabled, field.disabled, false)
        },
        updateFieldRequired(field: DtFieldInterface) {
            return this.updateField(field.id, field.onUpdateRequired, field.required, true)
        },
        buildFieldRows(fields: Array<DtFieldInterface>): Array<DtFieldInterface[]> {
            const collection: any = { }
            fields.forEach(field => {
                //Group fields with similar group name
                if (!field.group) {
                    collection[field.id] = [field]
                    return
                } 
                if (!(field.group in collection)) {
                    collection[field.group] = []
                }
                collection[field.group].push(field)
            })
            return Object.values(collection)
        }
    }
})
</script>
