<template>
    <ion-grid :style="{height:'99%', overflowX: 'auto'}"> 
        <ion-row
            v-for="(fields, rowIndex) in fieldRows"
            :key="rowIndex"
            >
            <ion-col
                v-for="(field, fieldIndex) in fields" 
                :key="fieldIndex"
                size="12" 
                size-sm
                v-show="updateFieldCondition(field)"
                >
                <ion-row> 
                    <ion-col> 
                        <ion-label 
                            :style="{ fontWeight: 'bold'}"
                            :class="{
                                'field-errors': hasErrors(field.id)
                            }">
                            {{ updateFieldHelpText(field) }}
                            <span v-if="updateFieldRequired(field)">(*)</span>
                        </ion-label>
                    </ion-col>
                </ion-row>
                <ion-row> 
                    <ion-col>    
                    <keep-alive> 
                    <component
                        v-bind:is="field.type"
                        :key="field.id"
                        :fdata="formData"
                        :cdata="computedData"
                        :field="field"
                        :clear="clearField"
                        :config="field.config"
                        :formUpdate="curFieldUpdate"
                        @onValue="(val) => onValue(val, field)">
                    </component>
                    </keep-alive>
                    </ion-col>
                </ion-row>
                <ion-row v-if="hasErrors(field.id)"> 
                    <ion-col class="error-message"> 
                        {{getErrors(field.id)}}
                    </ion-col>
                </ion-row>
            </ion-col>
        </ion-row>
        <ion-row>
            <ion-col size="6">
                <ion-button 
                    :disabled="isSubmitting || formHasErrors" 
                    @click="onSubmit">
                    Submit
                </ion-button>
            </ion-col>
            <ion-col size="6">
                <ion-button
                    color="danger"
                    :disabled="isSubmitting" 
                    @click="clearField='ALL'">
                    Clear
                </ion-button>
            </ion-col>
        </ion-row>
    </ion-grid>
</template>
<script lang="ts">
import { defineComponent, PropType } from 'vue'
import { DerivedInterface, DtFieldInterface } from "@/components/Forms/DesktopForms/DTFieldInterface"
import { Option } from "@/components/Forms/FieldInterface"
import { DesktopFormElements } from "@/components/Forms/DesktopForms/DTFormElements"
import {
    IonGrid,
    IonRow,
    IonCol,
    IonLabel,
    IonItem,
} from "@ionic/vue"
import { isEmpty } from 'lodash'
import { toastDanger, toastWarning } from '@/utils/Alerts'
export default defineComponent({
    components: { 
        IonGrid, 
        IonRow,
        IonCol,
        IonItem,
        IonLabel,
        ...DesktopFormElements
    },
    emits: [
        'onFinish'
    ],
    props: {
        onSubmitForm: {
            type: Function,
            required: true
        },
        fields: {
            type: Object as PropType<DtFieldInterface[]>,
            required: true   
        }
    },
    data: () => ({
        clearField: '' as string,
        fieldRows: [] as Array<DtFieldInterface[]>,
        formData: {} as Record<string, Option | Option[] | null>,
        computedData: {} as Record<string, any>,
        /**Track the field which is emitting a value */
        curFieldUpdate: { } as { 
            field: string;
            value: Option | Option[] | null;
        },
        /**Stores values generated by observer methods which derive data */
        observerValueCache: {} as Record<string, any>,
        fieldErrors: {} as Record<string, string[]>,
        fieldConditions: {} as Record<string, boolean>,
        isSubmitting: false
    }),
    watch: {
        fields: {
            handler(fields: DtFieldInterface[]) {
                if (!isEmpty(fields)) {
                    this.setFieldData(fields)
                    this.fieldRows = this.buildFieldRows(fields)
                }
            },
            deep: true,
            immediate: true
        }
    },
    computed: {
        formHasErrors(): boolean {
            const errors = Object.values(this.fieldErrors)
                .reduce((p: any, c: any) => [...p, ...c],[])
            return !isEmpty(errors)
        }
    },
    methods: {
        /**
         * Run field validations and submit
         */
        async onSubmit() {
            this.checkFieldErrors()

            if (this.formHasErrors) return toastWarning (
                'This form has errors, please correct them'
            )

            if (typeof this.onSubmitForm === 'function') {
                try {
                    this.isSubmitting = true
                    await this.onSubmitForm(this.formData, this.computedData)
                } catch(e) {
                    toastDanger(e)
                }
                this.isSubmitting = false
            } else {
                this.$emit('onFinish', this.formData, this.computedData)
            }
        },
        /**
         * Iterate all fields and detect validation errors
        */
        checkFieldErrors() {
            return this.fields.map((f) => this.validate(f)).every(Boolean)
        },
        /**
         * Updates field values in value store and performs validation prior to 
         * value update
         */
        onValue(value: Option | Option[] | null, field: DtFieldInterface) {
            this.curFieldUpdate = { field: field.id, value }
            this.formData[field.id] = value
            if (!this.validate(field))
                return
            if (value != null) {
                if (field.computeValue && value) {
                    this.computedData[field.id] = field.computeValue(
                        value, this.formData, this.computedData
                    )
                }
            }
        },
        validate(field: DtFieldInterface) {
            // Ignore validating field if it's set not to be visible
            if (!this.fieldConditions[field.id]) {
                return false
            }
            this.fieldErrors[field.id] = []
            const val = this.formData[field.id]

            if (this.updateFieldRequired(field) 
                && isEmpty(val)) {
                return this.fieldErrors[field.id] = [
                    "Value can't be Empty!"
                ]    
            }
            if (field.validation) {
                const errors = field.validation(
                    val, 
                    this.formData, 
                    this.computedData
                )
                if (errors) {
                    this.fieldErrors[field.id] = errors
                    return true
                }
            }
            return false
        },
        /**
         * Initialise data collection Hashes
         */
        setFieldData(fields: Array<DtFieldInterface>): void {
            this.formData = {};
            this.fieldConditions = {}
            this.fieldErrors = {}
            fields.forEach((field) => {
                // Track which fields are allowed to appear
                this.fieldConditions[field.id] = true
                // Track data collected on the form elements
                this.formData[field.id] = null
                // Track all field errors here
                this.fieldErrors[field.id] = []
            })
        },
        /**
         * Checks Errors Array with associated field ID
         */
        hasErrors(fieldID: string) {
            return !isEmpty(this.fieldErrors[fieldID])  
        },
        /**
         * Get Errors from Array with associated Field ID
         */
        getErrors(fieldID: string) {
            return this.fieldErrors[fieldID].join(',')
        },
        /**
         * Updates fields which derive data from other fields by running
         * watcher functions
         */
        updateField(
            fieldID: string,
            watcher: DerivedInterface | undefined, 
            configuredValue: 
                undefined 
                | string
                | number
                | boolean
                | Option
                | Promise<Option>
                | Option[]
                | Promise<Option[]>,
            defaultValue: any) {
            if (watcher!=undefined && !isEmpty(this.curFieldUpdate)) {
                if (isEmpty(watcher.observes) 
                    || watcher.observes.includes(this.curFieldUpdate.field)) {
                    this.observerValueCache[fieldID] = watcher.update(
                        this.curFieldUpdate.field,
                        this.curFieldUpdate.value,  
                        this.formData, 
                        this.computedData
                    )
                    return this.observerValueCache[fieldID]
                }
                if (this.observerValueCache[fieldID] != undefined) {
                    return this.observerValueCache[fieldID]
                }
            }
            if (configuredValue != undefined) {
                return configuredValue
            }
            return defaultValue
        },
        updateFieldHelpText(field: DtFieldInterface) {
            return this.updateField(field.id, field.onUpdateHelpText, field.helpText, 'Unknown')
        },
        /**
         * Set visibility of a form field on the page. 
         * Note: if field visibility is false, all field data is reset
         */
        updateFieldCondition(field: DtFieldInterface) {
            const ok = this.updateField(
                field.id, 
                field.onUpdateCondition, 
                field.condition, 
                true
            )
            if (!ok) {
                // Reset everything about this field
                this.fieldErrors[field.id] = []
                this.formData[field.id] = null
                // Force active field to clear it's data store
                this.clearField = field.id
                if (field.computeValue) 
                    this.computedData[field.id] = null
            }
            // update condition tracker
            this.fieldConditions[field.id] = ok === true
            return ok
        },
        updateFieldRequired(field: DtFieldInterface) {
            return this.updateField(field.id, field.onUpdateRequired, field.required, true)
        },
        /**
         * Converts fields into turples to represet rows on the form
         */
        buildFieldRows(fields: Array<DtFieldInterface>): Array<DtFieldInterface[]> {
            const collection: any = { }
            fields.forEach(field => {
                //Group fields with similar group name
                if (!field.group) {
                    collection[field.id] = [field]
                    return
                } 
                if (!(field.group in collection)) {
                    collection[field.group] = []
                }
                collection[field.group].push(field)
            })
            return Object.values(collection)
        }
    }
})
</script>
<style scoped>
    .error-message {
        color: red;
        font-style: italic;
        font-size: 0.8em;
    }
    .field-errors {
        color: red;
        font-weight: bold;
    }
</style>