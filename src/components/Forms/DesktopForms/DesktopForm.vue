<template>
    <ion-grid :style="{height:'99%', overflowX: 'auto'}"> 
        <ion-row
            v-for="(fieldTurples, sectionName) in fieldSectionData"
            :key="sectionName"
            >
            <ion-col size="12"> 
                <ion-row>
                    <ion-col> 
                        <h3 class="ion-text-center"> <b> {{sectionName}} </b> </h3>
                    </ion-col>
                </ion-row>
            </ion-col>
            <ion-col size="12" v-for="(fieldRows, rowIndex) in fieldTurples" :key="rowIndex">
                <ion-row>    
                    <ion-col
                        v-for="(field, fieldIndex) in fieldRows" 
                        :key="fieldIndex"
                        size="12" 
                        size-sm
                        v-show="updateFieldCondition(field)"
                        >
                        <ion-row> 
                            <ion-col> 
                                <ion-label
                                    :style="{ fontWeight: 'bold',  ...(field?.config?.label?.style ? field?.config?.label?.style : {})}"
                                    :class="hasErrors(field.id) ? 'field-errors' : (field.config?.label?.cssClass || '')">
                                    {{ updateFieldHelpText(field) }}
                                    <span v-if="updateFieldRequired(field)">(*)</span>
                                </ion-label>
                            </ion-col>
                        </ion-row>
                        <ion-row> 
                            <ion-col>    
                            <keep-alive> 
                            <component
                                v-bind:is="field.type"
                                :key="field.id"
                                :fdata="formData"
                                :cdata="computedData"
                                :field="field"
                                :clear="clearField"
                                :config="field.config"
                                :formUpdate="curFieldUpdate"
                                @onValue="(val) => onValue(val, field)">
                            </component>
                            </keep-alive>
                            </ion-col>
                        </ion-row>
                        <ion-row v-if="hasErrors(field.id)"> 
                            <ion-col class="error-message"> 
                                {{getErrors(field.id)}}
                            </ion-col>
                        </ion-row>
                    </ion-col>
                </ion-row>
            </ion-col>
        </ion-row>
        <slot
            name="buttons"
            :onSubmit="onSubmit" 
            :onClear="() => clearField='ALL'" 
            :isSubmitting="isSubmitting" 
            :hasErrors="formHasErrors">
        </slot>
    </ion-grid>
</template>
<script lang="ts">
import { defineComponent, PropType } from 'vue'
import { DerivedInterface, DtFieldInterface, DtFormSections } from "@/components/Forms/DesktopForms/DTFieldInterface"
import { Option } from "@/components/Forms/FieldInterface"
import { DesktopFormElements } from "@/components/Forms/DesktopForms/DTFormElements"
import {
    IonGrid,
    IonRow,
    IonCol,
    IonLabel,
    IonItem,
} from "@ionic/vue"
import { isEmpty } from 'lodash'
import { toastDanger, toastWarning } from '@/utils/Alerts'
export default defineComponent({
    components: { 
        IonGrid, 
        IonRow,
        IonCol,
        IonItem,
        IonLabel,
        ...DesktopFormElements
    },
    emits: [
        'onFinish'
    ],
    props: {
        onSubmitForm: {
            type: Function,
            required: true
        },
        fieldSections: {
            type: Object as PropType<DtFormSections[]>,
            required: true
        }
    },
    data: () => ({
        clearField: '' as string,
        fields: [] as DtFieldInterface[],
        fieldSectionData: [] as any,
        formData: {} as Record<string, Option | Option[] | null>,
        computedData: {} as Record<string, any>,
        /**Track the field which is emitting a value */
        curFieldUpdate: { } as { 
            field: string;
            value: Option | Option[] | null;
        },
        /**Stores values generated by observer methods which derive data */
        observerValueCache: {} as Record<string, any>,
        fieldErrors: {} as Record<string, string[]>,
        fieldConditions: {} as Record<string, boolean>,
        isSubmitting: false
    }),
    watch: {
        fieldSections: {
            handler(fieldSections: DtFormSections[]) {
                if (!isEmpty(fieldSections)) {
                    // Maintain a flat list of fields (with sections)
                    this.fields = fieldSections.reduce((fields: DtFieldInterface[], section: DtFormSections) => {
                        return [...fields, ...section.fields]
                    }, [])
                    this.setFieldData(this.fields)
                    this.fieldSectionData = this.buildfieldSectionData(fieldSections)
                }
            },
            deep: true,
            immediate: true
        }
    },
    computed: {
        formHasErrors(): boolean {
            const errors = Object.values(this.fieldErrors)
                .reduce((p: any, c: any) => [...p, ...c],[])
            return !isEmpty(errors)
        }
    },
    methods: {
        /**
         * Run field validations and submit
         */
        async onSubmit() {
            this.checkFieldErrors()

            if (this.formHasErrors) return toastWarning (
                'This form has errors, please correct them'
            )

            if (typeof this.onSubmitForm === 'function') {
                try {
                    this.isSubmitting = true
                    await this.onSubmitForm(this.formData, this.computedData)
                } catch(e) {
                    toastDanger(`${e}`)
                }
                this.isSubmitting = false
            } else {
                this.$emit('onFinish', this.formData, this.computedData)
            }
        },
        /**
         * Iterate all fields and detect validation errors
        */
        checkFieldErrors() {
            return this.fields.map((f) => this.validate(f)).every(Boolean)
        },
        /**
         * Updates field values in value store and performs validation prior to 
         * value update
         */
        onValue(value: Option | Option[] | null, field: DtFieldInterface) {
            this.curFieldUpdate = { field: field.id, value }
            this.formData[field.id] = value
            if (!this.validate(field))
                return
            if (value != null) {
                if (field.computeValue && value) {
                    this.computedData[field.id] = field.computeValue(
                        value, this.formData, this.computedData
                    )
                }
            }
        },
        validate(field: DtFieldInterface) {
            // Ignore validating field if it's set not to be visible
            if (!this.fieldConditions[field.id]) {
                return false
            }
            this.fieldErrors[field.id] = []
            const val = this.formData[field.id]

            if (this.updateFieldRequired(field) 
                && isEmpty(val)) {
                return this.fieldErrors[field.id] = [
                    "Value can't be Empty!"
                ]    
            }
            if (field.validation) {
                const errors = field.validation(
                    val, 
                    this.formData, 
                    this.computedData
                )
                if (errors) {
                    this.fieldErrors[field.id] = errors
                    return true
                }
            }
            return false
        },
        /**
         * Initialise data collection Hashes
         */
        setFieldData(fields: Array<DtFieldInterface>): void {
            this.formData = {};
            this.fieldConditions = {}
            this.fieldErrors = {}
            fields.forEach((field) => {
                // Track which fields are allowed to appear
                this.fieldConditions[field.id] = true
                // Track data collected on the form elements
                this.formData[field.id] = null
                // Track all field errors here
                this.fieldErrors[field.id] = []
            })
        },
        /**
         * Checks Errors Array with associated field ID
         */
        hasErrors(fieldID: string) {
            return !isEmpty(this.fieldErrors[fieldID])  
        },
        /**
         * Get Errors from Array with associated Field ID
         */
        getErrors(fieldID: string) {
            return this.fieldErrors[fieldID].join(',')
        },
        /**
         * Updates fields which derive data from other fields by running
         * watcher functions
         */
        updateField(
            fieldID: string,
            watcher: DerivedInterface | undefined, 
            configuredValue: 
                undefined 
                | string
                | number
                | boolean
                | Option
                | Promise<Option>
                | Option[]
                | Promise<Option[]>,
            defaultValue: any) {
            if (watcher!=undefined && !isEmpty(this.curFieldUpdate)) {
                if (isEmpty(watcher.observes) 
                    || watcher.observes.includes(this.curFieldUpdate.field)) {
                    this.observerValueCache[fieldID] = watcher.update(
                        this.curFieldUpdate.field,
                        this.curFieldUpdate.value,  
                        this.formData, 
                        this.computedData
                    )
                    return this.observerValueCache[fieldID]
                }
                if (this.observerValueCache[fieldID] != undefined) {
                    return this.observerValueCache[fieldID]
                }
            }
            if (configuredValue != undefined) {
                return configuredValue
            }
            return defaultValue
        },
        updateFieldHelpText(field: DtFieldInterface) {
            return this.updateField(field.id, field.onUpdateHelpText, field.helpText, 'Unknown')
        },
        /**
         * Set visibility of a form field on the page. 
         * Note: if field visibility is false, all field data is reset
         */
        updateFieldCondition(field: DtFieldInterface) {
            const ok = this.updateField(
                field.id, 
                field.onUpdateCondition, 
                field.condition, 
                true
            )
            if (!ok) {
                // Reset everything about this field
                this.fieldErrors[field.id] = []
                this.formData[field.id] = null
                // Force active field to clear it's data store
                this.clearField = field.id
                if (field.computeValue) 
                    this.computedData[field.id] = null
            }
            // update condition tracker
            this.fieldConditions[field.id] = ok === true
            return ok
        },
        updateFieldRequired(field: DtFieldInterface) {
            return this.updateField(field.id, field.onUpdateRequired, field.required, true)
        },
        /**
         * Build a grid sections of fields with related group names or field IDs
         */
        buildfieldSectionData(fields: DtFormSections[]): any {
            const data = fields.reduce((collection: any, data: any) => {
                if (!(data.section in collection)) {
                    collection[data.section] = {}
                } 
                // Group fields into turples
                data.fields.forEach((f: any) => {
                    if (!f.group) {
                        collection[data.section][f.id] = [f]
                    } else {
                        if (!(f.group in collection[data.section])) {
                            collection[data.section][f.group] = []
                        }
                        collection[data.section][f.group].push(f)
                    }
                })
                return collection
            }, {})
            // Assign fields to Section titles
            return Object.keys(data).reduce((sections: any, key: any) => {
                sections[key] = Object.values(data[key])
                return sections
            }, {})
        }
    }
})
</script>
<style scoped>
    .error-message {
        color: red;
        font-style: italic;
        font-size: 0.8em;
    }
    .field-errors {
        color: red;
        font-weight: bold;
    }
</style>